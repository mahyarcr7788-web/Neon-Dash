<!DOCTYPE html>
<html lang="en">
<head>
    <!-- SEO & META DATA -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Dash: Rhythm Gunner | Free Browser Rhythm Game</title>
    <meta name="description" content="Play Neon Dash: Rhythm Gunner for free! An addictive, fast-paced rhythm platformer where you jump, shoot, and dash to the beat. No download required.">
    <meta name="keywords" content="rhythm game, browser game, free games, platformer, neon dash, geometry dash alternative, music game, webgl game">
    <meta name="author" content="Master's AI">
    <meta name="robots" content="index, follow">
    
    <!-- Open Graph / Social Sharing -->
    <meta property="og:title" content="Neon Dash: Rhythm Gunner">
    <meta property="og:description" content="Can you survive the beat? Play the viral rhythm shooter now!">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://yourwebsite.com/neon-dash">
    <meta property="og:image" content="https://yourwebsite.com/thumbnail.jpg"> <!-- Replace with your actual URL later -->

    <!-- FONTS & STYLES -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">

    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            font-family: 'Orbitron', sans-serif;
            color: white;
            user-select: none;
            touch-action: none;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #000;
        }

        canvas {
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.1);
            max-width: 100%;
            max-height: 100%;
        }

        /* UI OVERLAY */
        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20;
        }

        .screen-panel {
            background: rgba(0, 0, 0, 0.9);
            padding: 40px 60px;
            border-radius: 10px;
            border: 2px solid #0ff;
            text-align: center;
            pointer-events: auto;
            box-shadow: 0 0 20px #0ff, inset 0 0 50px rgba(0,255,255,0.1);
            backdrop-filter: blur(5px);
            transition: opacity 0.3s;
        }

        h1 {
            font-size: 3.5rem;
            margin: 0;
            background: linear-gradient(to bottom, #fff, #0ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
            letter-spacing: 2px;
            text-transform: uppercase;
        }

        h2 { font-size: 1.2rem; color: #f0f; margin-top: 5px; text-shadow: 0 0 10px #f0f; }

        p { color: #aaa; font-size: 1rem; margin: 20px 0; line-height: 1.5; }

        .btn {
            background: transparent;
            color: #0ff;
            border: 2px solid #0ff;
            padding: 15px 40px;
            font-size: 1.5rem;
            font-weight: 700;
            font-family: 'Orbitron', sans-serif;
            cursor: pointer;
            text-transform: uppercase;
            transition: all 0.2s;
            margin-top: 10px;
        }

        .btn:hover {
            background: #0ff;
            color: #000;
            box-shadow: 0 0 20px #0ff;
            transform: scale(1.05);
        }

        /* HUD */
        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 1.5rem;
            color: #fff;
            text-shadow: 0 0 10px #0ff;
            pointer-events: none;
            z-index: 10;
        }
        
        #mode-indicator {
            position: absolute;
            bottom: 30px;
            right: 30px;
            font-size: 2rem;
            font-weight: 900;
            text-transform: uppercase;
            color: #0ff;
            text-shadow: 0 0 15px #0ff;
            opacity: 0.8;
            z-index: 10;
        }

        .hidden { display: none !important; opacity: 0; pointer-events: none; }

        /* CRT SCANLINES */
        .scanlines {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.1) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.03), rgba(0, 255, 0, 0.01), rgba(0, 0, 255, 0.03));
            background-size: 100% 3px, 6px 100%;
            pointer-events: none;
            z-index: 100;
            opacity: 0.6;
        }

        /* MOBILE ADJUSTMENTS */
        @media (max-width: 600px) {
            h1 { font-size: 2.5rem; }
            .screen-panel { padding: 20px 30px; width: 80%; }
            .btn { padding: 10px 30px; font-size: 1.2rem; }
        }
    </style>
</head>
<body>

<main id="game-container">
    <canvas id="gameCanvas"></canvas>
    <div class="scanlines"></div>

    <div id="hud">
        SCORE: <span id="score">0</span>
    </div>
    
    <div id="mode-indicator">JUMP MODE</div>

    <div id="ui-layer">
        <div id="start-screen" class="screen-panel">
            <h1>Neon Dash</h1>
            <h2>Rhythm Gunner</h2>
            <p><strong>PC:</strong> [Space] or Click to Jump/Shoot<br><strong>Mobile:</strong> Tap screen</p>
            <p style="font-size: 0.8rem; color: #666;">Use headphones for best experience</p>
            <button class="btn" onclick="startGame()">Start Game</button>
        </div>

        <div id="game-over-screen" class="screen-panel hidden">
            <h1 style="color: #f33; background: none; -webkit-text-fill-color: #f33; text-shadow: 0 0 20px #f00;">SYNC LOST</h1>
            <p>Final Score: <span id="final-score" style="color: #fff; font-weight: bold;">0</span></p>
            <p id="death-msg">Rhythm disconnected.</p>
            <button class="btn" onclick="resetGame()">Retry</button>
        </div>
    </div>
</main>

<script>
    /**
     * NEON DASH: RHYTHM GUNNER
     * Built for Master. Optimized for SEO & Performance.
     */
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d', { alpha: false }); // Optimize rendering
    
    // Audio Context
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    let audioCtx;
    let masterGain;

    // Game Constants
    const GRAVITY = 0.65;
    const JUMP_FORCE = -12;
    const SPEED_BASE = 9;
    
    // Game State
    let isRunning = false;
    let frames = 0;
    let score = 0;
    let gameSpeed = SPEED_BASE;
    let gameMode = 'jump'; // 'jump' or 'gun'
    let shake = 0;
    let bgHue = 180;
    let beatPhase = 0;

    // Arrays
    let particles = [];
    let bullets = [];
    let obstacles = [];

    // Player Object
    const player = {
        x: 100,
        y: 0,
        w: 40,
        h: 40,
        dy: 0,
        rotation: 0,
        grounded: false,
        color: '#0ff',
        trail: []
    };

    // Resize Handler
    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        // Keep floor consistent ratio
        player.baseY = canvas.height - 150 - player.h;
    }
    window.addEventListener('resize', resize);
    resize();

    // --- INPUT HANDLING ---
    function handleInput(e) {
        if (e && e.type === 'keydown' && e.code !== 'Space') return;
        if (e) e.preventDefault(); // Stop scrolling on space/touch

        if (!isRunning) return;
        
        if (gameMode === 'jump') {
            if (player.grounded) {
                player.dy = JUMP_FORCE;
                player.grounded = false;
                createParticles(player.x + 20, player.y + 40, '#fff', 5);
                playSound('kick');
            }
        } else if (gameMode === 'gun') {
            // Shoot
            bullets.push({
                x: player.x + player.w,
                y: player.y + player.h/2,
                w: 25, h: 6,
                vx: 18,
                color: '#fff'
            });
            // Visual Recoil
            player.x -= 8;
            shake = 6;
            playSound('snare');
        }
    }

    window.addEventListener('keydown', handleInput);
    window.addEventListener('mousedown', handleInput);
    window.addEventListener('touchstart', handleInput, {passive: false});

    // --- GAME CONTROL ---

    function initAudio() {
        if (!audioCtx) {
            audioCtx = new AudioContext();
            masterGain = audioCtx.createGain();
            masterGain.gain.value = 0.3; // Prevent ear blasting
            masterGain.connect(audioCtx.destination);
        }
        if(audioCtx.state === 'suspended') audioCtx.resume();
    }

    function startGame() {
        initAudio();
        document.getElementById('start-screen').classList.add('hidden');
        resetGameVars();
        isRunning = true;
        loop();
        scheduleMusic();
    }

    function resetGame() {
        document.getElementById('game-over-screen').classList.add('hidden');
        resetGameVars();
        isRunning = true;
        loop();
        // Music continues from scheduler
    }

    function resetGameVars() {
        player.y = player.baseY;
        player.dy = 0;
        player.rotation = 0;
        player.x = 100;
        player.color = '#0ff';
        
        score = 0;
        frames = 0;
        gameSpeed = SPEED_BASE;
        gameMode = 'jump';
        obstacles = [];
        bullets = [];
        particles = [];
        bgHue = 180;
        
        updateModeUI();
    }

    function updateModeUI() {
        const ind = document.getElementById('mode-indicator');
        if(gameMode === 'gun') {
            ind.innerText = "GUN MODE";
            ind.style.color = "#f00";
            ind.style.textShadow = "0 0 15px #f00";
        } else {
            ind.innerText = "JUMP MODE";
            ind.style.color = "#0ff";
            ind.style.textShadow = "0 0 15px #0ff";
        }
    }

    // --- GAME LOOP ---

    function spawnObstacle() {
        const type = Math.random();
        // Spawn distance based on speed
        const xPos = canvas.width + Math.random() * 200;
        const floorY = canvas.height - 150;
        
        // Minimum gap logic
        if (obstacles.length > 0) {
            const last = obstacles[obstacles.length-1];
            if (xPos - last.x < (gameMode === 'jump' ? 400 : 300)) return;
        }

        if (gameMode === 'jump') {
            if (type < 0.6) { // Spike
                obstacles.push({ type: 'spike', x: xPos, y: floorY - 40, w: 40, h: 40, color: '#f00' });
            } else if (type < 0.9) { // Block
                obstacles.push({ type: 'block', x: xPos, y: floorY - 40, w: 40, h: 40, color: '#f0f' });
            } else { // Portal
                obstacles.push({ type: 'portal', mode: 'gun', x: xPos, y: floorY - 140, w: 50, h: 140, color: '#0f0' });
            }
        } else { // Gun Mode
            if (type < 0.75) { // Wall (Shootable)
                obstacles.push({ type: 'wall', x: xPos, y: floorY - 100, w: 40, h: 100, hp: 1, color: '#ff0' });
            } else { // Portal
                obstacles.push({ type: 'portal', mode: 'jump', x: xPos, y: floorY - 140, w: 50, h: 140, color: '#0ff' });
            }
        }
    }

    function update() {
        frames++;
        score = Math.floor(frames / 5);
        document.getElementById('score').innerText = score;
        
        // Progression
        gameSpeed = Math.min(18, SPEED_BASE + (frames / 2000));
        
        // Background Beat Pulse
        if (frames % 30 === 0) bgHue = (bgHue + 15) % 360;

        const floorY = canvas.height - 150;

        // --- PLAYER UPDATE ---
        if (gameMode === 'jump') {
            player.dy += GRAVITY;
            player.y += player.dy;

            if (player.y + player.h >= floorY) {
                player.y = floorY - player.h;
                player.dy = 0;
                player.grounded = true;
                // Snap rotation to nearest 90
                player.rotation = Math.round(player.rotation / (Math.PI/2)) * (Math.PI/2);
            } else {
                player.grounded = false;
                player.rotation += 0.15;
            }
        } else {
            // Gun mode: run flat
            player.y = floorY - player.h;
            player.rotation = 0;
            // Smooth X return
            player.x += (100 - player.x) * 0.1; 
        }

        // Trail effect
        if (frames % 3 === 0) {
            player.trail.push({x: player.x, y: player.y, rotation: player.rotation, alpha: 0.5});
            if (player.trail.length > 5) player.trail.shift();
        }

        // --- OBSTACLES ---
        if (frames % Math.floor(600/gameSpeed) === 0) spawnObstacle(); // Dynamic spawn rate

        for (let i = obstacles.length - 1; i >= 0; i--) {
            let o = obstacles[i];
            o.x -= gameSpeed;

            // Collision
            if (player.x < o.x + o.w - 10 && player.x + player.w > o.x + 10 &&
                player.y < o.y + o.h - 10 && player.y + player.h > o.y + 10) {
                
                if (o.type === 'portal') {
                    gameMode = o.mode;
                    obstacles.splice(i, 1);
                    playSound('portal');
                    shake = 15;
                    player.color = (gameMode === 'gun') ? '#f00' : '#0ff';
                    updateModeUI();
                    // Clear nearby obstacles to prevent cheap deaths
                    obstacles = obstacles.filter(obs => obs.x > canvas.width); 
                } else {
                    gameOver();
                }
            }
            if (o.x < -100) obstacles.splice(i, 1);
        }

        // --- BULLETS ---
        for (let i = bullets.length - 1; i >= 0; i--) {
            let b = bullets[i];
            b.x += b.vx;
            
            // Hit Check
            for (let j = obstacles.length - 1; j >= 0; j--) {
                let o = obstacles[j];
                if (o.type === 'wall' && b.x > o.x && b.x < o.x + o.w && b.y > o.y && b.y < o.y + o.h) {
                    createParticles(o.x, o.y + o.h/2, '#ff0', 15);
                    playSound('hit');
                    obstacles.splice(j, 1);
                    bullets.splice(i, 1);
                    score += 50;
                    break;
                }
            }
            if (b.x > canvas.width) bullets.splice(i, 1);
        }

        // --- PARTICLES ---
        for (let i = particles.length - 1; i >= 0; i--) {
            let p = particles[i];
            p.x += p.vx;
            p.y += p.vy;
            p.life -= 0.04;
            if (p.life <= 0) particles.splice(i, 1);
        }

        if (shake > 0) shake *= 0.9;
        if (shake < 0.5) shake = 0;
    }

    function createParticles(x, y, color, count) {
        for(let i=0; i<count; i++) {
            particles.push({
                x: x, y: y,
                vx: (Math.random() - 0.5) * 12,
                vy: (Math.random() - 0.5) * 12,
                life: 1.0,
                color: color,
                size: Math.random() * 4 + 2
            });
        }
    }

    function gameOver() {
        isRunning = false;
        playSound('death');
        createParticles(player.x, player.y, player.color, 50);
        document.getElementById('final-score').innerText = score;
        
        const msgs = ["SYNC LOST", "RHYTHM FAILED", "BEAT DROPPED", "TRY AGAIN"];
        document.getElementById('death-msg').innerText = msgs[Math.floor(Math.random()*msgs.length)];
        document.getElementById('game-over-screen').classList.remove('hidden');
    }

    // --- RENDER ---
    function draw() {
        // Clear & Background
        ctx.fillStyle = `hsl(${bgHue}, 60%, 4%)`;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Shake
        ctx.save();
        if (shake > 0) ctx.translate((Math.random()-0.5)*shake, (Math.random()-0.5)*shake);

        const floorY = canvas.height - 150;

        // Grid Floor (Pseudo-3D)
        const offset = (frames * gameSpeed) % 100;
        ctx.strokeStyle = `hsl(${bgHue}, 100%, 20%)`;
        ctx.lineWidth = 2;
        
        // Vertical perspective lines
        for(let i = -100; i < canvas.width + 100; i+= 100) {
            let xLine = i - offset;
            ctx.beginPath();
            ctx.moveTo(xLine, floorY);
            ctx.lineTo(xLine - 100, canvas.height); 
            ctx.stroke();
        }
        // Horizon
        ctx.beginPath();
        ctx.moveTo(0, floorY);
        ctx.lineTo(canvas.width, floorY);
        ctx.strokeStyle = `hsl(${bgHue}, 100%, 50%)`;
        ctx.lineWidth = 3;
        ctx.shadowBlur = 10;
        ctx.shadowColor = ctx.strokeStyle;
        ctx.stroke();
        ctx.shadowBlur = 0;

        // Player Trail
        player.trail.forEach(t => {
            ctx.save();
            ctx.translate(t.x + player.w/2, t.y + player.h/2);
            ctx.rotate(t.rotation);
            ctx.globalAlpha = t.alpha * 0.3;
            ctx.fillStyle = player.color;
            ctx.fillRect(-player.w/2, -player.h/2, player.w, player.h);
            ctx.restore();
            t.alpha -= 0.05;
        });
        ctx.globalAlpha = 1.0;

        // Player
        if (isRunning || frames === 0) {
            ctx.save();
            ctx.translate(player.x + player.w/2, player.y + player.h/2);
            ctx.rotate(player.rotation);
            
            ctx.shadowBlur = 20;
            ctx.shadowColor = player.color;
            ctx.strokeStyle = player.color;
            ctx.lineWidth = 4;
            ctx.strokeRect(-player.w/2, -player.h/2, player.w, player.h);
            
            ctx.fillStyle = '#fff';
            ctx.fillRect(-10, -10, 20, 20); // Core
            
            if (gameMode === 'gun') {
                ctx.fillStyle = '#fff';
                ctx.fillRect(15, -4, 20, 8); // Gun Barrel
            }
            ctx.restore();
            ctx.shadowBlur = 0;
        }

        // Obstacles
        obstacles.forEach(o => {
            ctx.shadowBlur = 15;
            ctx.shadowColor = o.color;
            ctx.strokeStyle = o.color;
            ctx.lineWidth = 3;
            ctx.fillStyle = '#000';

            if (o.type === 'spike') {
                ctx.beginPath();
                ctx.moveTo(o.x, o.y + o.h);
                ctx.lineTo(o.x + o.w/2, o.y);
                ctx.lineTo(o.x + o.w, o.y + o.h);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
            } else if (o.type === 'block' || o.type === 'wall') {
                ctx.fillRect(o.x, o.y, o.w, o.h);
                ctx.strokeRect(o.x, o.y, o.w, o.h);
                if (o.type === 'wall') { // X pattern
                    ctx.beginPath();
                    ctx.moveTo(o.x, o.y); ctx.lineTo(o.x + o.w, o.y + o.h);
                    ctx.stroke();
                }
            } else if (o.type === 'portal') {
                ctx.beginPath();
                ctx.arc(o.x + o.w/2, o.y + o.h/2, 25, 0, Math.PI*2);
                ctx.stroke();
                ctx.fillStyle = o.color;
                ctx.globalAlpha = 0.3;
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }
        });

        // Bullets
        ctx.shadowBlur = 10;
        ctx.shadowColor = '#fff';
        ctx.fillStyle = '#fff';
        bullets.forEach(b => ctx.fillRect(b.x, b.y, b.w, b.h));
        ctx.shadowBlur = 0;

        // Particles
        particles.forEach(p => {
            ctx.globalAlpha = p.life;
            ctx.fillStyle = p.color;
            ctx.fillRect(p.x, p.y, p.size, p.size);
        });
        ctx.globalAlpha = 1.0;

        ctx.restore(); // End Shake
    }

    function loop() {
        if (!isRunning) return;
        update();
        draw();
        requestAnimationFrame(loop);
    }

    // --- AUDIO ENGINE 2.0 (High Quality) ---
    // Uses AudioContext scheduling for precise rhythm
    let nextNoteTime = 0;
    let beatIndex = 0;

    function scheduleMusic() {
        if (!isRunning) return;
        const lookahead = 0.1; 
        const tempo = 120; // BPM
        const secondsPerBeat = 60.0 / tempo;
        const noteRate = secondsPerBeat / 4; // 16th notes

        if (nextNoteTime < audioCtx.currentTime + lookahead) {
            playNote(nextNoteTime, beatIndex);
            nextNoteTime += noteRate;
            beatIndex = (beatIndex + 1) % 16;
        }
        requestAnimationFrame(scheduleMusic);
    }

    function playNote(time, index) {
        if (!masterGain) return;
        
        // 1. KICK (Every 4th 16th note = quarter note)
        if (index % 4 === 0) {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(masterGain);
            
            osc.frequency.setValueAtTime(150, time);
            osc.frequency.exponentialRampToValueAtTime(0.01, time + 0.5);
            gain.gain.setValueAtTime(1, time);
            gain.gain.exponentialRampToValueAtTime(0.001, time + 0.5);
            
            osc.start(time);
            osc.stop(time + 0.5);
        }

        // 2. SNARE (Beats 5 and 13)
        if (index === 4 || index === 12) {
             const osc = audioCtx.createOscillator();
             const gain = audioCtx.createGain();
             // Noise buffer would be better, but simple square works for 8-bit feel
             osc.type = 'square';
             osc.connect(gain);
             gain.connect(masterGain);
             
             osc.frequency.setValueAtTime(200, time);
             osc.frequency.linearRampToValueAtTime(100, time + 0.1);
             gain.gain.setValueAtTime(0.3, time);
             gain.gain.exponentialRampToValueAtTime(0.001, time + 0.2);
             
             osc.start(time);
             osc.stop(time + 0.2);
        }

        // 3. HI-HAT (Every off-beat 16th)
        if (index % 2 !== 0) {
             const osc = audioCtx.createOscillator();
             const gain = audioCtx.createGain();
             osc.type = 'triangle'; // Cleaner high freq
             osc.connect(gain);
             gain.connect(masterGain);
             
             // Very high pitch, short decay
             osc.frequency.setValueAtTime(8000, time);
             gain.gain.setValueAtTime(0.1, time);
             gain.gain.exponentialRampToValueAtTime(0.001, time + 0.05);
             
             osc.start(time);
             osc.stop(time + 0.05);
        }

        // 4. BASSLINE (Syncopated)
        // Simple pattern: X . . X . . X .
        if (index === 0 || index === 3 || index === 6 || index === 10) {
             const osc = audioCtx.createOscillator();
             const gain = audioCtx.createGain();
             osc.type = 'sawtooth';
             osc.connect(gain);
             gain.connect(masterGain);
             
             // Root note changes every 16 beats (Measure)
             const note = (Math.floor(frames / 120) % 2 === 0) ? 55 : 65; // A1 vs C#2
             
             osc.frequency.setValueAtTime(note, time);
             // Envelope
             gain.gain.setValueAtTime(0.2, time);
             gain.gain.linearRampToValueAtTime(0.0, time + 0.2);
             
             osc.start(time);
             osc.stop(time + 0.2);
        }
    }

    function playSound(type) {
        if (!audioCtx) return;
        const now = audioCtx.currentTime;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain);
        gain.connect(masterGain);

        if (type === 'kick') { // Jump
            osc.frequency.setValueAtTime(300, now);
            osc.frequency.exponentialRampToValueAtTime(0.01, now + 0.2);
            gain.gain.setValueAtTime(0.2, now);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
            osc.start(now);
            osc.stop(now + 0.2);
        } else if (type === 'snare') { // Shoot
            osc.type = 'square';
            osc.frequency.setValueAtTime(150, now);
            osc.frequency.linearRampToValueAtTime(50, now + 0.1);
            gain.gain.setValueAtTime(0.15, now);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
            osc.start(now);
            osc.stop(now + 0.1);
        } else if (type === 'hit') {
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(800, now);
            osc.frequency.exponentialRampToValueAtTime(100, now + 0.1);
            gain.gain.setValueAtTime(0.1, now);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
            osc.start(now);
            osc.stop(now + 0.1);
        } else if (type === 'portal') {
            osc.type = 'sine';
            osc.frequency.setValueAtTime(440, now);
            osc.frequency.linearRampToValueAtTime(880, now + 0.3);
            gain.gain.setValueAtTime(0.3, now);
            gain.gain.linearRampToValueAtTime(0, now + 0.3);
            osc.start(now);
            osc.stop(now + 0.3);
        } else if (type === 'death') {
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(100, now);
            osc.frequency.linearRampToValueAtTime(0, now + 0.5);
            gain.gain.setValueAtTime(0.4, now);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
            osc.start(now);
            osc.stop(now + 0.5);
        }
    }

</script>
</body>
</html>